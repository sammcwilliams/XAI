import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import shap
import os, sys

class Shap():
    """
    Subclass of XAI
    
    
    Contains functionality for using game theory's Shapley value technique to explain the impact 
    each feature has on the prediction.
    """
    def __init__(self, xai):
        self.model = xai.model
        self.train_x = xai.train_x
        self.train_y = xai.train_y
        self.xai = xai
        self.mode = xai.mode

    def shapley_tree(self, instances, feature_dependence="tree_path_dependent"):
        """
        -------------------------
        Args:
            instances: 2d array-type object containing feature data to be explained
            
            feature_dependence: string defining method by which to analyse tree. If "independent" then data is required by TreeExplainer module
        
        Returns:
            shap_values: in regression cases will return an array-type object with dimensions (n samples x x features)
                         in classification cases it will return one of these for each class value
        
            expected_value: the expected (Average) value for which all the features interact upon
            
        """
        instances = np.array(instances)
        #TYPE-CHECKING
        assert isinstance(instances, np.ndarray), "instances must be in array form"
        assert isinstance(feature_dependence, str), "feature dependence must be passed as a string"
        #VALUE-CHECKING
        assert instances.ndim == 2, "Instances passed must be in 2 dimensions"
        assert instances.shape[1] == self.train_x.shape[1], "Passed instances must have same number of features that the model was trained on"
        assert feature_dependence == "tree_path_dependent" or feature_dependence == "independent", "feature dependence must take the form either 'independent' or 'tree_path_dependent'"

        if feature_dependence != "tree_path_dependent":
            dataset = pd.DataFrame(self.train_x)
            dataset["Y"] = pd.Series(self.train_y, index=dataset.index)
            background_data = self.train_x
            explainer = shap.TreeExplainer(self.model.original, data=background_data, feature_dependence=feature_dependence)
        else:
            explainer = shap.TreeExplainer(self.model.original)
        shap_values = explainer.shap_values(np.array(instances))
        return shap_values, explainer.expected_value

    def shapley_interaction(self, instances, feature_dependence="tree_path_dependent"):
        """
        If feature_dependence argument is 'independent' then data is required by TreeExplainer module
        -------------------------
        Args:
            instances: 2d array-type object containing feature data to be explained
        
            feature_dependence: string taking value "independent" or "tree_path_dependent". Describes how TreeExplainer will attempt to explain
        
        Returns:
            shap_values: in regression cases will return an array-type object with dimensions (n samples x x features)
                         in classification cases it will return one of these for each class value
        
            expected_value: the expected (Average) value for which all the features interact upon
        
        """
        #TYPE-CHECKING
        assert isinstance(feature_dependence, str), "feature dependence must be passed as a string"
        #VALUE-CHECKING
        assert feature_dependence == "tree_path_dependent" or feature_dependence == "independent", "feature dependence must take the form either 'independent' or 'tree_path_dependent'"
        
        if feature_dependence != "tree_path_dependent":
            dataset = pd.DataFrame(self.train_x)
            dataset["Y"] = pd.Series(self.train_y, index=dataset.index)
            explainer = shap.TreeExplainer(self.model, data=dataset, feature_dependence=feature_dependence)
        else:
            explainer = shap.TreeExplainer(self.model)
        shap_inter = explainer.shap_interaction_values(instances)
        shap_inter = np.array(shap_inter)
        return shap_inter, explainer.expected_value

    def shapley_kernel(self, instances, link="identity", n_samples=100, min_samples=30):
        """
        Calculates the shapley values for all types of models. Is slower than the TreeExplainer and doesn't have functionality for calculating the interaction values.
        -------------------------
        Args:
            instances: 2d array-type object containing feature data to be explained
        
            link (str): "identity" or "logit"
            
            n_samples: integer indicating how many samples will be generated by the k means algorithm
            
            min_samples: integer indicating how many samples will be generated when mem_save is set
        
        Returns:
            shap_values: in regression cases will return an array-type object with dimensions (n samples x x features)
                         in classification cases it will return one of these for each class value
        
            expected_value: the expected (Average) value for which all the features interact upon
        
        """
        
        if self.xai.mem_save:
            print("WARNING: mem_save is set so reducing number of samples for background data from {} to {}.".format(n_samples, min_samples))
            n_samples = min_samples
        instances = np.array(instances)
        #TYPE-CHECKING
        assert isinstance(instances, np.ndarray), "instances must be in array form"
        assert "xgboost" not in self.model.model_type, "Can't use xgboost with this shapley method. Luckily for you though the shapley_tree function is quicker and more accurate than this one, so use that please :)"
        assert isinstance(link, str), "link argument must be passed as a string"
        assert isinstance(n_samples, int), "n_samples argument must be an integer"
        assert isinstance(min_samples, int), "min_samples argument must be an integer"
        #VALUE-CHECKING
        assert len(instances.shape) == 2, "Instances passed must be a 2D array or dataframe"
        assert instances.shape[1] == self.train_x.shape[1], "Passed instances must have same number of features that the model was trained on"
        assert link == "identity" or link == "logit", "link argument must take the form either 'identity' or 'logit'"
        assert min_samples > 0, "cannot generate a negative number of samples"
        assert n_samples > 0, "cannot generate a negative number of samples"
        assert n_samples < self.train_x.shape[0] and min_samples < self.train_x.shape[0], "you cannot (or should not) generate more samples than you have training data. So just don't :)"

        background_data = shap.kmeans(self.train_x, min(len(self.train_x)-1,n_samples))
        if self.mode == "regression":
            if link == "logit":
                print("Can't use logit link function with regression problems, changing to link='identity'...")
            explainer = shap.KernelExplainer(self.model.predict, background_data, link="identity")
        elif self.mode == "classification":
            explainer = shap.KernelExplainer(self.model.predict_proba, background_data, link=link)
        
        shap_values = np.array(explainer.shap_values(instances))
        
        if len(shap_values.shape) == 3 and shap_values.shape[0] == 1:
            shap_values = shap_values.reshape(instances.shape)
            
        ##TODO: Add functionality to automatically pair an instance's shapley values to its 
        ##expected value if labelled test data passed
            
        return shap_values, explainer.expected_value
        
    def plot_shapley(self, shap_values, expected, filename):
        """
        Takes the shapley values calculated previously and plots them. The plots are then saved to file.
        -------------------------
        Args:
        
            shap_values: 1D array-type object containing shapley values
        
            expected: float which represents the expected (~average~) value from which the shapley values are referring to
        
            filename: string denoting the desired name of the plot
        
            features (optional): 1D array-type containing feature data
        """
        shap_values = np.array(shap_values)
        expected = float(expected)
        #TYPE-CHECKING
        assert isinstance(shap_values, np.ndarray), "shapley values must be in array form"
        assert isinstance(expected, float), "expected value must be a float"
        assert isinstance(filename, str), "filename must be a string"
        assert np.array(list(shap_values)).dtype == np.dtype("float64") or np.array(list(shap_values)).dtype == np.dtype("float32"), "Values in the shap_values array must be in float format"
        
        assert len(shap_values.shape) == 1, "Saving the plot to file is only possible with one sample at a time"
        assert shap_values.shape == self.xai.features.shape, "features passed must be the same shape as the shapley values"
        
        fig = shap.force_plot(expected, shap_values, features=self.xai.features, show=False, matplotlib=True)
        plt.show()
        if not os.path.isdir("output/shapley"):
            os.mkdir("output/shapley")
        if ".png" not in filename:
            filename += ".png"
        plt.savefig("./output/shapley/{}".format(filename))
        
    def plot_shapley_full(self, shap_values, expected, X, filename=None):
        
        
        
        #NOT IN MATPLOTLIB YOU DONT
        #Duplicate of above
        
        #TODO
        
        
        
        """
        Takes the shapley values calculated previously and plots them. The plots are then saved to file.
        -------------------------
        Args:
        
            shap_values: 1D array-type object containing shapley values
        
            expected: float which represents the expected (~average~) value from which the shapley values are referring to
        
            filename: string denoting the desired name of the plot
        
            features (optional): 1D array-type containing feature data
        """
        shap_values = np.array(shap_values)
        expected = float(expected)
        #TYPE-CHECKING
        assert isinstance(shap_values, np.ndarray), "shapley values must be in array form"
        assert isinstance(expected, float), "expected value must be a float"
        assert isinstance(filename, str), "filename must be a string"
        assert np.array(list(shap_values)).dtype == np.dtype("float64"), "Values in the shap_values array must be in float format"
        
        #assert len(shap_values.shape) == 1, "Saving the plot to file is only possible with one sample at a time"
        #assert shap_values.shape == self.xai.features.shape, "features passed must be the same shape as the shapley values"
        
        fig = shap.force_plot(expected, shap_values, features=X, show=False, matplotlib=True)
        plt.show(fig)
        if filename == None:
            filename = input("What filename would you like for the shapley plot? (.png): ")
        plt.savefig(filename)
        
    def standard_plot(self, shap_values, expect, filename, class_name=None):
        

        fig = plt.figure()
        vals = shap_values.tolist()
        names = self.xai.features.tolist()
        vals.reverse()
        names.reverse()
        colors = ['green' if x > 0 else 'red' for x in shap_values]
        pos = np.arange(len(vals)) + .5
        plt.barh(pos, vals, align='center', color=colors, left=expect)
        plt.yticks(pos, names)
        if self.mode == "classification" and class_name is not None:
            title = 'Shapley Explanation for class {}'.format
        else:
            title = 'Shapley Explanation'
        plt.title(title)
        plt.tight_layout()
        plt.savefig(filename)
        plt.show()
        
        #WEIRD COLOURS HAPPENING IDK WHY
        #STILL WORKS DOE
        
        return fig
        
    def summary_plot(self, shap_values, data, filename, **kwargs):
        plt.subplots()
        shap.summary_plot(shap_values, features=data, feature_names=self.xai.features, plot_type="violin", **kwargs)
        plt.title("Summary of Shapley Values")
        plt.tight_layout()
        if not os.path.isdir("output/shapley"):
            os.mkdir("output/shapley")
        if ".png" not in filename:
            filename += ".png"
        plt.savefig("./output/shapley/{}".format(filename))
        
    def plot_interactions(self, shap_inter, instance):
        """
        DOCSTRINGS ARE FOR WORTHY FUNCTIONS ONLY
        """
        if self.mode == "classification":
            prediction_idx = 2#np.argmax(self.model.predict_proba(instance.reshape(1,-1)))
            shap.dependence_plot(ind=("petal length (cm)","petal length (cm)"), shap_values=shap_inter[prediction_idx], features=instance, feature_names=self.xai.features)
        else:
            shap.dependence_plot(ind=("petal length (cm)","petal length (cm)"), shap_values=shap_inter, features=instance, feature_names=self.xai.features)
        plt.savefig("wassup-tho")